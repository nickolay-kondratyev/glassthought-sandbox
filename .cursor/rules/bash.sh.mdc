---
description: Rules for writing robust bash scripts and bash functions.
globs: *.sh
---

## Bash Script Best Practices

This document outlines key guidelines for writing robust bash scripts. Each section describes **what** to do, provides an **example** (with input code and usage if applicable), and explains **why** it is important or outlines best practices.

### Mandatory Variable Checks

#### What
Ensure required parameters are provided using parameter expansion with error messages.

#### Example

##### Input
```bash
local file_path="${1:?file name or path}"
```

##### Usage
```bash
echo "file=[${file_path:?}]"
```

#### Why
Guarantees that the script stops with a clear error if a required variable is missing.
?
---

### Proper Quoting

#### What
Always quote variable expansions to avoid unexpected word splitting and globbing.

#### Example

##### Input
```bash
echo "file=[${file_path:?}]"
```

#### Why
- Preserves spaces and special characters.
- Produces predictable and reliable output.

---

### Local Scope for Variables

#### What
Within functions, use `local` to restrict variable scope and prevent leakage into the global environment.

#### Example

##### Input
```bash
some.function.name() {
  local file_path="${1:?file name or path}"
  # Process the file
}
```

#### Why
Limits side effects by keeping variables contained within the function.

---

### DRY Principle (Don't Repeat Yourself)

#### What
Encapsulate common logic into functions to avoid duplicating code.

#### Example

##### Input
```bash
string.prefix(){
  local prefix="${1:?Prefix is required}"
  
  if [ -t 0 ]; then
    local input_string="${2:?Input string is required when not piping}"
    echo "${prefix}${input_string}"
  else
    while IFS= read -r line; do
      echo "${prefix}${line}"
    done
  fi
}

```

#### Why
- Simplifies maintenance.
- Reduces the risk of errors from repetitive code.
- Makes it easier to understand and modify the script.

---

### Self-Documenting Code

#### What
Write clear, descriptive code that explains itself through naming conventions and succinct comments.

#### Best Practices
- Use meaningful names for variables and functions.
- Comment on the intent and rationale behind decisions, not just the actions.

---

### Consistent Error Handling

#### What
Implement a uniform error-handling mechanism: `throw` function, to manage failures consistently.

#### `throw` is already implemented as:
```bash
throw(){
  interrupt "${*}"
}

interrupt(){
    echo.red "Interrupting: ${*}" 1>&2;
    echo.yellow "FunctionChain: $(function_chain)" 1>&2;
    echo.yellow "PWD: $PWD" 1>&2;
    echo.yellow "PID    : $$" 1>&2;
    echo.yellow "BASHPID: $BASHPID" 1>&2;
    interrupt_quietly
}

interrupt_quietly(){
    kill -INT 0;
    kill -INT -$$;
    echo.red "Interrupting failed. We will now 'exit 1' to make sure we aren't continuing with a failed state." 1>&2;
    exit 1
}
```

#### Usage example
```bash
[ -f "$file_path" ] || throw "File does not exist: ${file_path}"
```

#### Why
Provides a predictable method for error handling, enhancing the script's robustness and readability.

