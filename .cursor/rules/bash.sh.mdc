---
description: Rules for writing robust and maintainable BASH scripts and functions.
globs: *.sh
---


### Mandatory Variable Checks

#### What 
Ensure required parameters are provided using parameter expansion with error messages:

#### Example
##### Input 
```bash
local file_path="${1:?file name or path}"
```
#### Usage
```bash
echo "file=[${file_path:?}]"
```

#### Why
Guarantees that the script stops with a clear error if a required variable is missing.

### Proper Quoting

#### What
Always quote variable expansions to avoid unexpected word splitting and globbing:

#### Example
```bash
echo "file=[${file_path:?}]"
```

#### Why
- Preserves spaces and special characters.
- Produces predictable and reliable output.


### Local Scope for Variables

Within functions, use `local` to restrict variable scope:

```bash
process.file() {
  local file_path="${1:?file name or path}"
  # Process the file
}
```

**Why:**  
Limits side effects by preventing variables from affecting the global environment.

---

## 5. DRY Principle (Don't Repeat Yourself)

Avoid duplicating code by encapsulating common logic into functions.

**Example:**

```bash
function log_message() {
  local message="${1:?message text}"
  echo "Log: ${message}"
}

log_message "Starting process"
```

**Benefits:**

- Simplifies maintenance.
- Reduces the risk of errors in repetitive code.

---

## 6. Self-Documenting Code

Adopt clear, descriptive naming conventions and add succinct comments that explain **why** certain decisions were made.

**Best Practices:**

- Use meaningful names for variables and functions.
- Comment on the intent and rationale, not just the actions.

---

## 7. Consistent Error Handling

Implement a dedicated error-handling mechanism, such as a `throw` function, to manage failures uniformly:

```bash
function throw() {
  local error_message="${1:?error message}"
  echo "Error: ${error_message}" >&2
  exit 1
}

# Usage example:
[ -f "$file_path" ] || throw "File does not exist: ${file_path}"
```


