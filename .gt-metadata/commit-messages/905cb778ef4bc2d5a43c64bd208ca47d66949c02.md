#### Code
```kotlin
package com.glassthought.sandbox

import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlin.system.measureNanoTime

fun main() = runBlocking {
  val iterations = 1_000_000

  // Operation without mutex
  var counterWithoutMutex = 0
  val timeWithoutMutex = measureNanoTime {
    repeat(iterations) {
      counterWithoutMutex++
    }
  }

  println("Counter without mutex: $counterWithoutMutex")
  println("Time taken without mutex: $timeWithoutMutex ns")

  // Operation with mutex
  val mutex = Mutex()
  var counterWithMutex = 0
  val timeWithMutex = measureNanoTime {
    repeat(iterations) {
      mutex.withLock {
        counterWithMutex++
      }
    }
  }

  println("Counter with mutex: $counterWithMutex")
  println("Time taken with mutex: $timeWithMutex ns")

  // Calculate overhead per mutex operation
  val overheadPerOperation = (timeWithMutex - timeWithoutMutex) / iterations
  println("Overhead of Mutex.withLock{} per operation: $overheadPerOperation ns")

  // In relation to millisecond how many times can we take mutex in one millisecond
  // There is 1000 microseconds in one millisecond
  // There is 1,000,000 in one millisecond
  val timesPerMillisecond = 1_000_000 / overheadPerOperation
  println("In relation to millisecond how many times can we take mutex in one millisecond: $timesPerMillisecond")
}
```

#### Command to reproduce:
```bash
gt.sandbox.checkout.commit 905cb778ef4bc2d5a43c \
&& cd "${GT_SANDBOX_REPO}" \
&& cmd.run.announce "./gradlew run --quiet"
```

#### Recorded output of command:
```txt
Counter without mutex: 1000000
Time taken without mutex: 2954000 ns
Counter with mutex: 1000000
Time taken with mutex: 28521834 ns
Overhead of Mutex.withLock{} per operation: 25 ns
In relation to millisecond how many times can we take mutex in one millisecond: 40000
```
