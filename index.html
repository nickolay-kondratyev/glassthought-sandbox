<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>3‑D Force Graph · LOD Textured Cubes · Quest 3 VR</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
      html, body {
          margin: 0;
          padding: 0;
          overflow: hidden;
      }

      #graph {
          width: 100vw;
          height: 100vh;
      }
  </style>

  <!-- libs -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/webxr/VRButton.js"></script>
  <script src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
</head>
<body>
  <div id="graph"></div>

  <script>
      // ---------- Graph Data ----------
      const N = 10000; // Increased node count
      const nodes = [...Array(N).keys()].map(i => ({
          id: String(i),
          name: `Node ${i}`,
          val: 3 + Math.random() * 12,
          color: `hsl(${Math.random() * 360},70%,60%)`,
          group: Math.floor(Math.random() * 5)   // group 0 gets custom LOD cube
      }));

      const links = [];
      nodes.forEach(({id, group}) => {
          // Create fewer links for a large graph to maintain performance
          const numLinks = Math.random() < 0.1 ? 2 : 1; // Average 1.1 links per node
          for (let k = 1; k <= numLinks; k++) {
              if (Math.random() < 0.5) { // Reduce density further
                  links.push({source: id, target: String((+id + k) % N), value: Math.random() * 2 + 0.5});
              }
          }
          if (Math.random() > 0.9) { // Reduce random cross-links
              links.push({source: id, target: String(Math.floor(Math.random() * N)), value: Math.random() + 0.2});
          }
      });
      console.log(`Generated ${nodes.length} nodes and ${links.length} links.`);

      // ---------- Load Texture ----------
      const texLoader = new THREE.TextureLoader();
      texLoader.crossOrigin = 'anonymous';
      const nodeTexture = texLoader.load('https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/PNG_transparency_demonstration_1.png/640px-PNG_transparency_demonstration_1.png');

      // ---------- Shared Geometries & Materials for LOD ----------
      const rMultiplier = 5; // Keep this for scaling consistency

      // High Detail (Textured Cube)
      const highDetailBoxGeometry = new THREE.BoxGeometry(1, 1, 1); // Unit cube, will be scaled
      const sharedCubeMaterials = Array(6).fill().map(() => new THREE.MeshBasicMaterial({
          map: nodeTexture,
          transparent: true, // Texture has transparency
          alphaTest: 0.1     // Avoid rendering fully transparent pixels, helps with sorting
      }));

      // Medium Detail (Solid Color Cube - reuses highDetailBoxGeometry)
      // Material will be created per node due to unique color

      // Low Detail (Solid Color Sphere)
      const lowDetailSphereGeometry = new THREE.SphereGeometry(1, 8, 6); // Unit sphere, will be scaled

      // ---------- Create Graph ----------
      const graph = ForceGraph3D({
          extraRendererConfig: {antialias: true, alpha: true, xr: {enabled: true}}
      })(document.getElementById('graph'))
          .backgroundColor('#111133')
          .graphData({nodes, links})
          .linkWidth(l => l.value * 0.5) // Adjusted for potentially more links
          .nodeLabel(n => n.name)
          .linkDirectionalParticles(1) // Reduced particles for performance
          .linkDirectionalParticleWidth(link => link.value * 0.3) // Adjusted
          .nodeThreeObjectExtend(false) // We provide the full object
          .nodeThreeObject(node => {
              if (node.group !== 0) {
                  // For nodes not in group 0, let 3d-force-graph use its default sphere.
                  // You could also define a different, simpler LOD or non-LOD object here.
                  return undefined;
              }

              const lod = new THREE.LOD();
              const baseSize = Math.cbrt(node.val); // Base size factor from node.val
              const scale = baseSize * rMultiplier;

              // --- High Detail Level (Textured Cube) ---
              const highDetailMesh = new THREE.Mesh(highDetailBoxGeometry, sharedCubeMaterials);
              highDetailMesh.scale.set(scale, scale, scale);
              highDetailMesh.updateMatrix();
              highDetailMesh.matrixAutoUpdate = false;
              lod.addLevel(highDetailMesh, 0);

              // --- Medium Detail Level (Solid Color Cube) ---
              const mediumDetailMaterial = new THREE.MeshBasicMaterial({color: node.color});
              const mediumDetailMesh = new THREE.Mesh(highDetailBoxGeometry, mediumDetailMaterial);
              mediumDetailMesh.scale.set(scale * 0.5, scale * 0.5, scale * 0.5);
              mediumDetailMesh.updateMatrix();
              mediumDetailMesh.matrixAutoUpdate = false;
              lod.addLevel(mediumDetailMesh, 60); // Adjust this distance as needed

              // --- Low Detail Level (Solid Color Sphere) ---
              const lowDetailMaterial = new THREE.MeshBasicMaterial({color: node.color});
              const lowDetailMesh = new THREE.Mesh(lowDetailSphereGeometry, lowDetailMaterial);
              lowDetailMesh.scale.set(scale * 0.3, scale * 0.3, scale * 0.3);
              lowDetailMesh.updateMatrix();
              lowDetailMesh.matrixAutoUpdate = false;
              lod.addLevel(lowDetailMesh, 120); // Adjust this distance as needed

              return lod;
          });

      // ---------- Force Engine Tuning ----------
      // These settings help optimize performance, especially when nodes move after initial stabilization.

      // 1. Tune the Charge Force (Repulsion)
      const chargeForce = graph.d3Force('charge');
      if (chargeForce) {
          chargeForce
              .strength(-60) // Adjust repulsion strength. Default is -30. More negative = stronger repulsion.
              // Experiment with this value in conjunction with theta.
              .theta(1.2);   // Increase Barnes-Hut approximation. Default is 0.9.
                             // Values > 1 make distant node interactions less precise but faster.
                             // This helps "far nodes care less" computationally.
      }

      // 2. Adjust Link Force (Springs between connected nodes) - Optional
      // const linkForce = graph.d3Force('link');
      // if (linkForce) {
      //     linkForce
      //         .distance(40) // Desired link length. Default is 30.
      //         .strength(0.05); // Link stiffness. Default is auto-calculated based on node degree.
      //                        // You might need to set an explicit, possibly lower, strength.
      // }

      // 3. Reduce Centering Force Strength
      // The centering force pulls the whole graph towards the origin.
      // A strong centering force can cause widespread movement if the graph's balance shifts.
      const centerForce = graph.d3Force('center');
      if (centerForce) {
          centerForce.strength(0.05); // Default is 1. Try a much smaller value to reduce global "pull."
      }

      // 4. Make the Simulation Cool Down Faster
      graph.d3AlphaDecay(0.04); // Default is ~0.0228. Higher values mean faster decay.
                                // This reduces the number of simulation ticks after a disturbance.

      // 5. Increase Friction (Optional)
      // graph.d3VelocityDecay(0.5); // Default is 0.4. Higher values (0 to 1) mean more friction.
      // Nodes will stop moving sooner.

      // ---------- Lighting ----------
      graph.scene().add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 50, 50); // Position light further for larger graph
      graph.scene().add(dirLight);

      // ---------- VR Support ----------
      document.body.appendChild(VRButton.createButton(graph.renderer()));

      // ---------- Frame Camera ----------
      // Adjust zoomToFit parameters for a larger graph.
      // The padding might need to be larger, or zoom slightly more out.
      setTimeout(() => graph.zoomToFit(1000, 150), 1500); // Increased padding and delay for layout

      // Optional: Add camera controls for easier debugging of LOD distances
      // import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; // if you were using modules
      // const controls = new OrbitControls(graph.camera(), graph.renderer().domElement);
      // controls.enableDamping = true;
      // function animate() {
      //    controls.update();
      //    requestAnimationFrame(animate);
      // }
      // if (typeof OrbitControls !== 'undefined') animate(); // Check if OrbitControls is available
  </script>
</body>
</html>
